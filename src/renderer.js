// src/renderer.js

// ===== DOM =====
const btnChoose = document.getElementById('btnChoose');
const folderPathEl = document.getElementById('folderPath');
const btnRun = document.getElementById('btnRun');
const btnPreview = document.getElementById('btnPreview'); // ÏûàÏùÑ Í≤ΩÏö∞ ÎèôÏûë, ÏóÜÏúºÎ©¥ Î¨¥Ïãú
const statusEl = document.getElementById('status');
const bar = document.getElementById('bar');
const logEl = document.getElementById('log');
const previewGrid = document.getElementById('previewGrid'); // ÏûàÏùÑ Í≤ΩÏö∞ ÎèôÏûë, ÏóÜÏúºÎ©¥ Î¨¥Ïãú

const wmText = document.getElementById('wmText');
const fontSize = document.getElementById('fontSize');
const fontSizeMode = document.getElementById('fontSizeMode');
const rowFontSizePx = document.getElementById('rowFontSizePx');
const textColor = document.getElementById('textColor');
const fontFamily = document.getElementById('fontFamily');
const fontFamilySelect = document.getElementById('fontFamilySelect');
const fontPreview = document.getElementById('fontPreview');
const opacity = document.getElementById('opacity');
const position = document.getElementById('position');
const margin = document.getElementById('margin');
const maxWidth = document.getElementById('maxWidth');
const shadowColor = document.getElementById('shadowColor');
const shadowOffsetX = document.getElementById('shadowOffsetX');
const shadowOffsetY = document.getElementById('shadowOffsetY');
const shadowBlur = document.getElementById('shadowBlur');
const outlineColor = document.getElementById('outlineColor');
const outlineWidth = document.getElementById('outlineWidth');
const logo = document.getElementById('logo');



// ===== Persistence Keys =====
const STORAGE_KEY = 'wmOptions.v1';
const FOLDER_KEY = 'wmLastFolder.v1';

let chosenFolder = null;

// ===== Persistence helpers =====
function getCurrentOptionsSnapshot() {
  return {
    text: (wmText.value || '').trim(),
    fontSize: Number(fontSize.value) || 36,
    fontSizeMode: (fontSizeMode?.value || 'percent'),
    textColor: (textColor?.value || '#ffffff'),
    fontFamily: (fontFamily?.value || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif"),
    opacity: Math.max(0, Math.min(1, Number(opacity.value) || 0.35)),
    position: position.value,
    margin: Number(margin.value) || 24,
    maxWidth: Number(maxWidth.value) || 0,
    shadowColor: (shadowColor?.value || '#000000'),
    shadowOffsetX: (Number.isFinite(Number(shadowOffsetX?.value)) ? Number(shadowOffsetX?.value) : 2),
    shadowOffsetY: (Number.isFinite(Number(shadowOffsetY?.value)) ? Number(shadowOffsetY?.value) : 2),
    shadowBlur: (Number.isFinite(Number(shadowBlur?.value)) ? Number(shadowBlur?.value) : 0),
    outlineColor: (outlineColor?.value || '#000000'),
    outlineWidth: (Number.isFinite(Number(outlineWidth?.value)) ? Number(outlineWidth?.value) : 0),
    // logo ÌååÏùºÏùÄ Î≥¥ÏïàÏÉÅ Í≤ΩÎ°ú/Í∞í Ï†ÄÏû• X (Î∏åÎùºÏö∞Ï†ÄÍ∞Ä file input Î≥µÏõêÏùÑ Í∏àÏßÄ)
  };
}

function applyOptionsToUI(opts) {
  if (!opts) return;
  if (typeof opts.text === 'string') wmText.value = opts.text;
  if (Number.isFinite(opts.fontSize)) fontSize.value = String(opts.fontSize);
  if (typeof opts.fontSizeMode === 'string' && fontSizeMode) fontSizeMode.value = opts.fontSizeMode;
  if (typeof opts.textColor === 'string' && textColor) textColor.value = opts.textColor;
  if (typeof opts.fontFamily === 'string' && fontFamily) fontFamily.value = opts.fontFamily;
  if (Number.isFinite(opts.opacity)) opacity.value = String(opts.opacity);
// Helper to toggle font size mode visibility
function updateFontSizeModeVisibility() {
}
  if (typeof opts.position === 'string') position.value = opts.position;
  if (Number.isFinite(opts.margin)) margin.value = String(opts.margin);
  if (Number.isFinite(opts.maxWidth)) maxWidth.value = String(opts.maxWidth);
  if (typeof opts.shadowColor === 'string' && shadowColor) shadowColor.value = opts.shadowColor;
  if (Number.isFinite(opts.shadowOffsetX) && shadowOffsetX) shadowOffsetX.value = String(opts.shadowOffsetX);
  if (Number.isFinite(opts.shadowOffsetY) && shadowOffsetY) shadowOffsetY.value = String(opts.shadowOffsetY);
  if (Number.isFinite(opts.shadowBlur) && shadowBlur) shadowBlur.value = String(opts.shadowBlur);
  if (typeof opts.outlineColor === 'string' && outlineColor) outlineColor.value = opts.outlineColor;
  if (Number.isFinite(opts.outlineWidth) && outlineWidth) outlineWidth.value = String(opts.outlineWidth);
}

function saveOptions() {
  try {
    const snap = getCurrentOptionsSnapshot();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(snap));
  } catch (e) {
    console.error('saveOptions error:', e);
  }
}

function loadOptions() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    applyOptionsToUI(parsed);
    updateFontSizeModeVisibility(); // Manually update UI after loading options
    return parsed;
  } catch (e) {
    console.error('loadOptions error:', e);
    return null;
  }
}

function saveLastFolder(pathStr) {
  try {
    localStorage.setItem(FOLDER_KEY, pathStr || '');
  } catch (e) {
    console.error('saveLastFolder error:', e);
  }
}

function loadLastFolder() {
  try {
    const v = localStorage.getItem(FOLDER_KEY);
    return v || null;
  } catch (e) {
    console.error('loadLastFolder error:', e);
    return null;
  }
}

// ===== IPC Progress =====
window.api.onProgress((data) => {
  const { current, total, file, ok, message } = data;
  if (total > 0) bar.style.width = `${Math.floor((current / total) * 100)}%`;
  const line = `${ok ? '‚úÖ' : '‚ùå'} [${current}/${total}] ${file}${message ? ' ‚Äî ' + message : ''}`;
  logEl.textContent += line + '\n';
  logEl.scrollTop = logEl.scrollHeight;
});

// ===== Folder choose =====
btnChoose.addEventListener('click', async () => {
  const folder = await window.api.chooseFolder();
  if (folder) {
    chosenFolder = folder;
    folderPathEl.textContent = folder;
    saveLastFolder(folder);
  }
});

// ===== Build options for IPC (includes reading logo bytes) =====
async function buildOptionsForIPC() {
  // Ï†ÄÏû•ÎèÑ Í∞ôÏù¥
  saveOptions();

  let logoBytes = null;
  if (logo.files && logo.files[0]) {
    const buf = await logo.files[0].arrayBuffer();
    logoBytes = new Uint8Array(buf); // structured clone OK
  }
  const snap = getCurrentOptionsSnapshot();
  
  // Í∞úÎ≥Ñ Ïù¥ÎØ∏ÏßÄ ÏúÑÏπò Ï†ïÎ≥¥ Ìè¨Ìï®
  const imagePositionsArray = Array.from(imagePositions.entries()).map(([filePath, posData]) => {
    console.log('Sending position for:', filePath, '‚Üí', posData);
    return {
      filePath,
      position: posData
    };
  });
  
  console.log('Total image positions:', imagePositionsArray.length);
  return { ...snap, logoBytes, imagePositions: imagePositionsArray };
}

// ===== Run All =====
btnRun.addEventListener('click', async () => {
  if (!chosenFolder) {
    statusEl.textContent = 'Choose a target folder first.';
    return;
  }

  statusEl.textContent = 'Processing all files‚Ä¶';
  logEl.textContent = '';
  bar.style.width = '0%';

  try {
    const options = await buildOptionsForIPC(); // saveOptions Ìè¨Ìï®
    
    // Ïù¥ÎØ∏ÏßÄÏôÄ ÎèôÏòÅÏÉÅÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
    const imageSummary = await window.api.processImages({ folder: chosenFolder, options });
    const videoSummary = await window.api.processVideos({ folder: chosenFolder, options });
    
    const totalFiles = imageSummary.total + videoSummary.total;
    const totalSucceeded = imageSummary.succeeded + videoSummary.succeeded;
    const totalFailed = imageSummary.failed + videoSummary.failed;
    
    statusEl.textContent = `ÏôÑÎ£å! Ï¥ù ${totalFiles}Í∞ú ÌååÏùº Ï§ë ${totalSucceeded}Í∞ú ÏÑ±Í≥µ, ${totalFailed}Í∞ú Ïã§Ìå® (Ïù¥ÎØ∏ÏßÄ: ${imageSummary.succeeded}/${imageSummary.total}, ÎèôÏòÅÏÉÅ: ${videoSummary.succeeded}/${videoSummary.total})`;
  } catch (e) {
    statusEl.textContent = 'Error: ' + e.message;
  }
});

// ===== Preview (optional UI present) =====
async function readOptionsForPreview(filePath = null) {
  // ÌîÑÎ¶¨Î∑∞ÏóêÏÑúÎèÑ Ï†ÄÏû•
  saveOptions();

  let logoBytes = null;
  if (logo.files && logo.files[0]) {
    const buf = await logo.files[0].arrayBuffer();
    logoBytes = new Uint8Array(buf);
  }
  const snap = getCurrentOptionsSnapshot();
  
  // ÌäπÏ†ï ÌååÏùºÏùò Í∞úÎ≥Ñ ÏúÑÏπò ÏÑ§Ï†ïÏù¥ ÏûàÏúºÎ©¥ Ï†ÅÏö©
  if (filePath && imagePositions.has(filePath)) {
    const imagePosition = imagePositions.get(filePath);
    if (imagePosition.type === 'custom') {
      snap.position = imagePosition;
    } else {
      snap.position = imagePosition.type;
    }
  }
  
  // ÎèôÏòÅÏÉÅ ÌîÑÎ¶¨Î∑∞Î•º ÏúÑÌï¥ Ï†ÑÏ≤¥ imagePositions Î∞∞Ïó¥ÎèÑ Ìè¨Ìï®
  const imagePositionsArray = Array.from(imagePositions.entries()).map(([filePath, posData]) => ({
    filePath,
    position: posData
  }));
  
  return { ...snap, logoBytes, maxWidth: 0, imagePositions: imagePositionsArray }; // ÌîÑÎ¶¨Î∑∞Îäî ÎÇ¥Î∂ÄÏóêÏÑú Ï∂ïÏÜå Î†åÎçî
}

// Í∞Å Ïù¥ÎØ∏ÏßÄÏùò Í∞úÎ≥Ñ ÏúÑÏπò ÏÑ§Ï†ïÏùÑ Ï†ÄÏû•
let imagePositions = new Map();

function renderInteractivePreviews(dataUrls, filePaths, originalImages) {
  if (!previewGrid) return;
  previewGrid.innerHTML = '';
  
  dataUrls.forEach((url, i) => {
    const filePath = filePaths[i];
    const fileName = filePath.split('/').pop();
    
    // Initialize position for this image if not exists
    if (!imagePositions.has(filePath)) {
      const initialPosition = { type: position.value || 'southeast' };
      imagePositions.set(filePath, initialPosition);
    }

    const card = document.createElement('div');
    card.className = 'preview-card';
    card.dataset.filePath = filePath;

    const cap = document.createElement('div');
    cap.className = 'filename';
    const ext = filePath.split('.').pop()?.toLowerCase();
    const isVideo = ['mp4', 'mov', 'm4v', 'mkv', 'webm', 'avi'].includes(ext);
    cap.innerHTML = `${isVideo ? 'üé¨ ' : 'üñºÔ∏è '}${fileName}`;

    const imageContainer = document.createElement('div');
    imageContainer.style.position = 'relative';

    const img = document.createElement('img');
    img.src = url;
    img.addEventListener('click', () => {
      const lb = document.getElementById('lightbox');
      const lbImg = document.getElementById('lightboxImg');
      if (!lb || !lbImg) return;
      // Ìï≠ÏÉÅ ÏµúÏã† ÎØ∏Î¶¨Î≥¥Í∏∞ Ïù¥ÎØ∏ÏßÄÎ•º ÏÇ¨Ïö©
      lbImg.src = img.src;
      lb.style.display = 'flex';
    });

    // ÏõåÌÑ∞ÎßàÌÅ¨ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ±
    const overlay = document.createElement('div');
    overlay.className = 'watermark-overlay';
    overlay.dataset.imageIndex = i;
    
    // Ïª®Ìä∏Î°§ Ìå®ÎÑê
    const controls = document.createElement('div');
    controls.className = 'preview-controls';
    const posIndicator = document.createElement('span');
    posIndicator.className = 'position-indicator';
    posIndicator.textContent = `Position: ${imagePositions.get(filePath).type}`;
    controls.appendChild(posIndicator);

    imageContainer.appendChild(img);
    imageContainer.appendChild(overlay);
    
    card.appendChild(cap);
    card.appendChild(imageContainer);
    card.appendChild(controls);
    previewGrid.appendChild(card);

    // Ïù¥ÎØ∏ÏßÄ Î°úÎìú ÌõÑ ÏõåÌÑ∞ÎßàÌÅ¨ ÏúÑÏπò ÏÑ§Ï†ï
    img.onload = async () => {
      const { overlayWidth, overlayHeight } = await setupWatermarkOverlay(overlay, img, filePath, i);
      updateOverlayPosition(overlay, img, filePath, overlayWidth, overlayHeight);
    };
  });
}

// Ïã§Ï†ú ÏõåÌÑ∞ÎßàÌÅ¨ ÌÅ¨Í∏∞Î•º Ï†ïÌôïÌûà Í≥ÑÏÇ∞ÌïòÎäî Ìï®Ïàò
async function calculateActualWatermarkSize(img, filePath) {
  try {
    const opts = await readOptionsForPreview(filePath);
    // Ïã§Ï†ú Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞ Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
    const originalImg = new Image();
    return new Promise((resolve) => {
      originalImg.onload = () => {
        const imgRect = img.getBoundingClientRect();
        const previewScale = imgRect.width / originalImg.width;

        const shortEdge = Math.min(originalImg.width, originalImg.height);
        const mode = (opts.fontSizeMode || 'percent');
        let effFont = 36;
        if (mode === 'percent') {
          const pct = Number(opts.fontSize) || 5;
          effFont = Math.max(12, Math.min(256, Math.round(shortEdge * (pct / 100))));
        } else {
          effFont = Math.max(12, Math.min(256, Math.round(Number(opts.fontSize) || 36)));
        }

        // Ïä§ÏºÄÏùºÎßÅÎêú Ìè∞Ìä∏Î°ú ÌÖçÏä§Ìä∏ ÌÅ¨Í∏∞ Ï∏°Ï†ï
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const text = opts.text || '';
        ctx.font = `${effFont}px ${opts.fontFamily || 'Arial'}`;
        const textMetrics = ctx.measureText(text);
        const actualWidth = textMetrics.width * previewScale;
        const actualHeight = effFont * previewScale * 1.2;
        resolve({ width: actualWidth, height: actualHeight, scale: previewScale });
      };
      originalImg.src = img.src;
    });
  } catch (e) {
    // Ìè¥Î∞±: Í∏∞Î≥∏ Î°úÏßÅÏúºÎ°ú ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
    const fontSize = Number(document.getElementById('fontSize')?.value || 36);
    const text = document.getElementById('wmText')?.value || '';
    const fontFamily = document.getElementById('fontFamily')?.value || 'Arial';
    const imgRect = img.getBoundingClientRect();
    // Í∏∞Î≥∏ Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞Î•º Ï∂îÏ†ï (Ïòà: 800px Í∏∞Ï§Ä)
    const estimatedOriginalWidth = 800;
    const fontScale = estimatedOriginalWidth / 800; // 1.0
    const scaledFontSize = fontSize * fontScale;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${scaledFontSize}px ${fontFamily}`;
    const textMetrics = ctx.measureText(text);
    return {
      width: textMetrics.width,
      height: scaledFontSize * 1.2,
      scale: 1
    };
  }
}

async function setupWatermarkOverlay(overlay, img, filePath, imageIndex) {
  const imgRect = img.getBoundingClientRect();
  
  // Ïã§Ï†ú ÏõåÌÑ∞ÎßàÌÅ¨ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
  const watermarkSize = await calculateActualWatermarkSize(img, filePath);
  let overlayWidth = watermarkSize.width;
  let overlayHeight = watermarkSize.height;
  
  overlay.style.width = overlayWidth + 'px';
  overlay.style.height = overlayHeight + 'px';
  
  // Ï¥àÍ∏∞ ÌÅ¨Í∏∞Î•º Ïò§Î≤ÑÎ†àÏù¥Ïóê Ï†ÄÏû•Ìï¥ÏÑú ÎÇòÏ§ëÏóê Ï∞∏Ï°∞Ìï† Ïàò ÏûàÎèÑÎ°ù Ìï®
  overlay.dataset.initialWidth = overlayWidth;
  overlay.dataset.initialHeight = overlayHeight;

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let lastUpdateTime = 0;
  let currentImgRect; // Variable to store imgRect on mousedown

  overlay.addEventListener('mousedown', (e) => {
    isDragging = true;
    overlay.classList.add('dragging');
    const overlayRect = overlay.getBoundingClientRect();
    startX = e.clientX - overlayRect.left;
    startY = e.clientY - overlayRect.top;
    currentImgRect = img.getBoundingClientRect(); // Calculate imgRect on mousedown
    e.preventDefault();
    e.stopPropagation();
  });

  const onMouseMove = (e) => {
    if (!isDragging) return;
    
    const x = e.clientX - currentImgRect.left - startX;
    const y = e.clientY - currentImgRect.top - startY;
    
    // ÌòÑÏû¨ Ïò§Î≤ÑÎ†àÏù¥Ïùò Ïã§Ï†ú ÌÅ¨Í∏∞ ÏÇ¨Ïö© (ÎèôÏ†ÅÏúºÎ°ú Î≥ÄÌï† Ïàò ÏûàÏùå)
    const currentWidth = overlay.offsetWidth;
    const currentHeight = overlay.offsetHeight;
    
    const clampedX = Math.max(0, Math.min(x, currentImgRect.width - currentWidth));
    const clampedY = Math.max(0, Math.min(y, currentImgRect.height - currentHeight));
    
    // Ï¶âÏãú Ïò§Î≤ÑÎ†àÏù¥ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (Î∂ÄÎìúÎü¨Ïö¥ ÎìúÎûòÍ∑∏)
    overlay.style.left = clampedX + 'px';
    overlay.style.top = clampedY + 'px';
    
    // Ï¢åÌëú Í≥ÑÏÇ∞ÏùÄ throttle Ï†ÅÏö© (60fps = 16ms)
    const now = Date.now();
    if (now - lastUpdateTime > 16) {
      lastUpdateTime = now;
      
      // Ïã§Ï†ú Ïù¥ÎØ∏ÏßÄ Ï¢åÌëúÎ°ú Î≥ÄÌôòÌïòÏó¨ Ï†ÄÏû•
      const originalImg = new Image();
      originalImg.onload = () => {
        const scaleX = originalImg.width / currentImgRect.width;
        const scaleY = originalImg.height / currentImgRect.height;
        const realX = Math.round(clampedX * scaleX);
        const realY = Math.round(clampedY * scaleY);
        
        // Ï¢åÌëúÎ•º ÎπÑÏú®Î°úÎèÑ Ï†ÄÏû• (Îçî ÏïàÏ†ïÏ†ÅÏù∏ Îß§Ïπ≠ÏùÑ ÏúÑÌï¥)
        const ratioX = clampedX / currentImgRect.width;
        const ratioY = clampedY / currentImgRect.height;
        
        const newPosition = {
          type: 'custom',
          x: realX,
          y: realY,
          ratioX: ratioX,
          ratioY: ratioY
        };
        console.log('Saving position for:', filePath, '‚Üí', newPosition);
        imagePositions.set(filePath, newPosition);
        
        // Ïª®Ìä∏Î°§ Ìå®ÎÑê ÏóÖÎç∞Ïù¥Ìä∏
        const card = overlay.closest('.preview-card');
        const indicator = card.querySelector('.position-indicator');
        if (indicator) {
          indicator.textContent = `Position: custom (${realX}, ${realY})`;
        }
      };
      originalImg.src = img.src;
    }
  };

  const onMouseUp = () => {
    if (isDragging) {
      isDragging = false;
      overlay.classList.remove('dragging');
      
      // ÎìúÎûòÍ∑∏ ÏôÑÎ£å ÌõÑ ÏõåÌÑ∞ÎßàÌÅ¨ Ï†ÅÏö©Îêú ÏÉà ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉùÏÑ±
      const card = overlay.closest('.preview-card');
      refreshPreviewImage(filePath, card);
    }
  };

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);

  // Clean up event listeners when the element is removed
  overlay.addEventListener('removed', () => {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
  });

  return { overlayWidth, overlayHeight };
}

async function updateOverlayPosition(overlay, img, filePath, overlayWidth, overlayHeight) {
  const posData = imagePositions.get(filePath);
  const imgRect = img.getBoundingClientRect();
  
  if (!posData) {
    console.warn('No position data for', filePath);
    return;
  }
  
  // For custom positions set by dragging, use the ratio-based positioning.
  if (posData.type === 'custom' && posData.ratioX !== undefined && posData.ratioY !== undefined) {
    const x = posData.ratioX * imgRect.width;
    const y = posData.ratioY * imgRect.height;
    
    const maxX = Math.max(0, imgRect.width - (overlayWidth || overlay.offsetWidth));
    const maxY = Math.max(0, imgRect.height - (overlayHeight || overlay.offsetHeight));
    
    overlay.style.left = Math.min(x, maxX) + 'px';
    overlay.style.top = Math.min(y, maxY) + 'px';
    return;
  }

  // For preset positions, calculate the position using the switch statement.
  const margin = Number(document.getElementById('margin')?.value || 24);
  const w = overlayWidth || overlay.offsetWidth || 200;
  const h = overlayHeight || overlay.offsetHeight || 30;
  
  let x = 0, y = 0;
  switch (posData.type) {
    case 'northwest':
      x = margin;
      y = margin;
      break;
    case 'northeast':
      x = imgRect.width - w - margin;
      y = margin;
      break;
    case 'north':
      x = Math.floor((imgRect.width - w) / 2);
      y = margin;
      break;
    case 'southwest':
      x = margin;
      y = imgRect.height - h - margin;
      break;
    case 'south':
      x = Math.floor((imgRect.width - w) / 2);
      y = imgRect.height - h - margin;
      break;
    case 'center':
      x = Math.floor((imgRect.width - w) / 2);
      y = Math.floor((imgRect.height - h) / 2);
      break;
    default: // southeast
      x = imgRect.width - w - margin;
      y = imgRect.height - h - margin;
  }
  
  overlay.style.left = Math.max(0, x) + 'px';
  overlay.style.top = Math.max(0, y) + 'px';
}

// Debounce Îßµ (ÌååÏùºÎ≥ÑÎ°ú ÎèÖÎ¶ΩÏ†ÅÏù∏ debounce)
const refreshDebounceMap = new Map();

// ÏõåÌÑ∞ÎßàÌÅ¨Í∞Ä Ï†ÅÏö©Îêú ÏÉàÎ°úÏö¥ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± (Debounced)
function refreshPreviewImage(filePath, card) {
  // Í∏∞Ï°¥ debounce ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
  if (refreshDebounceMap.has(filePath)) {
    clearTimeout(refreshDebounceMap.get(filePath));
  }
  
  // ÏÉà debounce ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï (300ms ÌõÑ Ïã§Ìñâ)
  const timeoutId = setTimeout(async () => {
    try {
      const opts = await readOptionsForPreview(filePath);
      const dataUrl = await window.api.previewImage({ filePath, options: opts });
      
      const img = card.querySelector('img');
      if (img) {
        img.src = dataUrl;
      }
    } catch (e) {
      console.error('Failed to refresh preview:', e);
    } finally {
      refreshDebounceMap.delete(filePath);
    }
  }, 300);
  
  refreshDebounceMap.set(filePath, timeoutId);
}

if (btnPreview) {
  btnPreview.addEventListener('click', async () => {
    if (!chosenFolder) {
      statusEl.textContent = 'Choose a target folder first.';
      return;
    }
    
    // ÏÉÅÌÉúÏ∞ΩÍ≥º Ïù¥Ï†Ñ ÎØ∏Î¶¨Î≥¥Í∏∞ Î¶¨ÏÖã
    statusEl.textContent = 'Loading interactive previews‚Ä¶';
    if (previewGrid) previewGrid.innerHTML = '';
    
    const logEl = document.getElementById('log');
    const barEl = document.getElementById('bar');
    if (logEl) logEl.textContent = '';
    if (barEl) barEl.style.width = '0%';
    
    // Run Î≤ÑÌäº Ïà®Í∏∞Í∏∞ (ÎØ∏Î¶¨Î≥¥Í∏∞ ÏôÑÎ£å ÌõÑ Îã§Ïãú ÌëúÏãú)
    const btnRun = document.getElementById('btnRun');
    if (btnRun) btnRun.style.display = 'none';

    try {
      const fileList = await window.api.listImages(chosenFolder);
      const allFiles = [...(fileList.images || []), ...(fileList.videos || [])];

      const previews = [];
      for (const f of allFiles) {
        const opts = await readOptionsForPreview(f); // Í∞Å ÌååÏùºÎ≥Ñ Í∞úÎ≥Ñ ÏòµÏÖò Ï†ÅÏö©
        const dataUrl = await window.api.previewImage({ filePath: f, options: opts });
        previews.push(dataUrl);
      }

      renderInteractivePreviews(previews, allFiles, allFiles);
      const imageCount = (fileList.images || []).length;
      const videoCount = (fileList.videos || []).length;
      statusEl.textContent = `üéØ Interactive preview ready (${imageCount} images, ${videoCount} videos). Drag watermarks to adjust positions.`;
      
      // ÎØ∏Î¶¨Î≥¥Í∏∞ ÏôÑÎ£å ÌõÑ Run Î≤ÑÌäº ÌëúÏãú
      if (btnRun) {
        btnRun.style.display = 'block';
        // Î≤ÑÌäº ÎÇòÌÉÄÎÇòÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥º
        btnRun.style.opacity = '0';
        btnRun.style.transform = 'translateY(10px)';
        setTimeout(() => {
          btnRun.style.transition = 'all 0.3s ease';
          btnRun.style.opacity = '1';
          btnRun.style.transform = 'translateY(0)';
        }, 100);
      }
    } catch (e) {
      statusEl.textContent = 'Preview error: ' + e.message;
    }
  });
}



// ===== Auto-restore on load =====
 (function init() {
  // 1) ÏòµÏÖò Î≥µÏõê
  loadOptions();

  // 2) ÎßàÏßÄÎßâ Ìè¥Îçî Í≤ΩÎ°ú Î≥µÏõê (Î≥¥ÏïàÏÉÅ ÏûêÎèôÏúºÎ°ú ÌååÏùº Îã§Ïù¥ÏñºÎ°úÍ∑∏Î•º Ïó¥ ÏàòÎäî ÏóÜÏùå)
  const last = loadLastFolder();
  if (last) {
    chosenFolder = last;
    folderPathEl.textContent = last;
  }

  // 3) ÏûÖÎ†• Î≥ÄÍ≤Ω Ïãú ÏûêÎèô Ï†ÄÏû• (ÎîîÎ∞îÏö¥Ïä§ ÏóÜÏù¥ Îã®Ïàú Ï≤òÎ¶¨)
  [wmText, fontSize, textColor, fontFamily, opacity, position, margin, maxWidth, shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur, outlineColor, outlineWidth].forEach(el => {
    if (!el) return;
    const ev = el.tagName === 'SELECT' ? 'change' : 'input';
    el.addEventListener(ev, saveOptions);
  });

  

  // 4) ÏãúÏä§ÌÖú Ìè∞Ìä∏ Î™©Î°ù Î°úÎìúÌïòÏó¨ datalist/ÏÖÄÎ†âÌä∏ Ï±ÑÏö∞Í∏∞ + ÎØ∏Î¶¨Î≥¥Í∏∞
  const dl = document.getElementById('fontList');
  if ((dl || fontFamilySelect) && window.api?.listSystemFonts) {
    window.api.listSystemFonts().then(fonts => {
      const list = (fonts || []).slice(0, 500);
      if (dl) {
        dl.innerHTML = '';
        list.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f;
          dl.appendChild(opt);
        });
      }
      if (fontFamilySelect) {
        fontFamilySelect.innerHTML = '<option value="">‚Äî System Fonts ‚Äî</option>';
        list.forEach(f => {
          const o = document.createElement('option');
          o.value = f;
          o.textContent = f;
          fontFamilySelect.appendChild(o);
        });
        const applyPreview = (family) => {
          if (!fontPreview) return;
          const familyCss = family && family.indexOf(' ') >= 0 && !family.includes(',') ? `'${family}'` : family;
          fontPreview.style.fontFamily = familyCss || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
        };
        // select Î≥ÄÍ≤Ω Ïãú
        fontFamilySelect.addEventListener('change', () => {
          if (!fontFamily) return;
          if (fontFamilySelect.value) fontFamily.value = fontFamilySelect.value;
          applyPreview(fontFamilySelect.value);
          saveOptions();
        });
        // input ÌÉÄÏù¥Ìïë ÏãúÎèÑ ÎØ∏Î¶¨Î≥¥Í∏∞
        if (fontFamily) {
          fontFamily.addEventListener('input', () => applyPreview(fontFamily.value));
        }
        // Ï¥àÍ∏∞ ÎØ∏Î¶¨Î≥¥Í∏∞
        applyPreview(fontFamily?.value);
      }
    }).catch(() => {});
  }



  // ÎùºÏù¥Ìä∏Î∞ïÏä§ Îã´Í∏∞ (Î∞∞Í≤Ω ÌÅ¥Î¶≠)
  const lb = document.getElementById('lightbox');
  if (lb) {
    lb.addEventListener('click', (e) => {
      if (e.target === lb) lb.style.display = 'none';
    });
  }
})();

  if (fontSizeMode) {
    fontSizeMode.addEventListener('change', () => {
      updateFontSizeModeVisibility();
      saveOptions();
    });
    // Ï¥àÍ∏∞ Í∞ÄÏãúÏÑ±
    updateFontSizeModeVisibility();
  }